# Code Smells Generales

## 1 Multiples Lenguajes en un Fichero

Tener mucha syntax diferente en un único archivo a la larga puede crear confusión

Hay casos en el que un poco puede ser práctico (Como css en un archivo Js)

Pero no respetar esta regla a la larga es fatídico

## 2 Comportamiento Obvio no implementado

Si una función funciona muy diferente con parametros parecidos, está mal

Hace que no exista confianza en el código y se tenga que revisar línea por línea

## 3 Comportamiento Incorrecto en los límites
Probar de manera general las funciones es incorrecto

Se debe de analizar el problema a resolver correctamente

En el ejemplo de abajo, la función falla en los años bisiestos
![Función en limite incorrecta](/Images/Screenshot%20Capture%20-%202023-11-06%20-%2013-29-50.png)

## 4 Anular mecanismos de seguridad
+ Deshabilitar warnings del compilador
+ Comentar o Ignorar test que están fallando
+ Ignorar los reportes de plataforrmas de analisis de código (SonarQue)

## 5 Duplicidad 
+ La duplicidad en el código representa una oportunidad perdida para crear una nueva abstracción

+ El código repetido se puede abstraer en un método o incluso una clase

+ La duplicidad en varias clases puede indicar la necesidad de una jerarquía


Si existe un cambio en una parte, este repercute en todas cuando tenemos duplicidad

## 6 Código en el nivel de abstracción Incorrecto

![](/Images/Screenshot%20Capture%20-%202023-11-06%20-%2013-51-57.png)

En este ejemplo no todos los vehiculos tienen un Radio, se tendría que hacer otra que extienda de Vehicle

## 7 Clases base dependen de las  derivadas
![](/Images/Screenshot%20Capture%20-%202023-11-06%20-%2015-20-14.png)

Este método pertenece realmente a las clases Rectangle y Triangle ya que la **Variable** que se utiliza para obtener el número de lados se obtiene de una SubClase, no de la clase Padre

## 8 Demasiada Información

+ Módulos bien definidos tienen **Interfaces muy pequeñas** que permiten hacer mucho con pocos métodos

+ Se muestra lo estricatmente necesario

+ En OOP, esconde tus datos, ofrece operaciones

## 9 Código Muerto

+ El código que no se ejecuta **se debe eliminar indmediatamente**
    + Funciones que no se llaman
    + Condiciones en Switch/Case o If que no se dan unnca
    + Try Catch con excepciones que **Nunca** se lanzan

+ El control de versiones recordará todo!

## 10 Distancia Vertical

+ Las Variables y Funciones **deben de estar cerca de donde se usen**
    + Las variables locales se deben declarar justo antes de usarlas
    + Las funciones privadas deben de estar justo debajo de la primera función que se usa

+ No queremos que código local esté situado a cientos de líneas de donde sea (Se complica la lectura)

## 11 Inconsistencia

+ Si haces algo de cierta manera, **hazlo siempre de la misma forma**

    + Un ejemplo, si utilizas la palabra _Processor_ en _UserRequestProcessor_, no crees la clase _AdminRequestHandler_
    + Si utilizas la palabra deletee para las _eliminaciones_, no uses _Remove_

+ La consistencia **hace que nuestro código sea mucho más fácil de leer**

## 12 Basura

+ Constructores por defecto sin la implementación
+ Getters y Setters de asbolutamente todas las variables privadas de una clase
+ Variables que no se usan
+ Funciones que nunca se llaman

## 13 Acoplamiento Artificial

* Los elementos que no dependan uno del otro no deben de estar acoplados
![](/Images/Screenshot%20Capture%20-%202023-11-06%20-%2016-44-46.png)

En la Clase Circle no debe de estar PI

ya que no pertenece unicamente al Circle y si otra clase la requiere **NO** tendría que acceder a Circle

## 14 Envidia del ámbito de otra clase

**Envidia** _Cuando una clase está interesada en mucha información de otra clase_

+ Los métodos de una clase deben de estar interesados en sus propias variables y funciones 

![](/Images/Screenshot%20Capture%20-%202023-11-06%20-%2016-47-50.png)

La clase GameRankCalculator tiene Demasiada información de User en el método _calculateRank_, tanto que lo que hace y lo que obtiene, iría mejor en la clase de User.

En otras palabras ese método se tiene que establecer en User.

## 15 Flags

+ Un flag como argumento suele indicar que la función hace más de una cosa
![](/Images/Screenshot%20Capture%20-%202023-11-06%20-%2016-53-03.png)

Esto hace que la función tenga que hacer 2 cosas

_**Una función debe de hacer una sola cosa y hacerla bien**_

## 16 Intenciones ocultas o difíciles de apreciar

+ El código debe de ser lo más expresivo posible

+ De dana vale un código que ocupe poco espacio si no lo entendemos

![](/Images/Screenshot%20Capture%20-%202023-11-07%20-%2013-09-25.png)

## 17 Responsabilidad Fuera de Lugar

+ El código debe de ser escrito en el **lugar más natural para un lector**

+ No escribir el código donde más nos convenfa en un momento, si no es donde se esperaría leer

+ Si usas PI, lo más recomendado es que esté en una Clase Math, que en una de un rectangulo o un circulo


## 18 Métodos Estáticos Inapropiados

+ Los métodos estáticos **no operan con ninguna instancia**

Ejemplo:

En la siguiente función, se calcula el pago.

![](/Images/Screenshot%20Capture%20-%202023-11-07%20-%2013-20-27.png)

Esto se puede lograr haciendo que la función opeere recibiendo el tipo de Employee (Clase), para que así se pueda ajustar dentro de la misma y funcione de manera diferente para cada tipo

**Pero** Lo más recomendable (Así evitar un code smell ~ Funciones hacen varias cosas)
Es hacer que _calculatePay_ esté elaborada en cada una de las Clases de Employee y esta se ajuste a cada uno de los escenarios.
